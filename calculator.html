<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Shifting Sarcastic Calculator</title>
    
    <style>
        /* Basic Reset and Setup */
        body {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background-color: #ffcccc;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; 
        }

        /* Calculator Container */
        #calculator {
            width: 90vw;
            height: 90vh;
            padding: 20px;
            background-color: #fff0b3;
            border: 5px dashed #ff6666;
            box-shadow: 10px 10px 0px #aa0000;
            position: relative; 
            transition: opacity 0.5s; 
        }

        /* The Animation Stage */
        #animation-stage {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #333; 
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 3em;
            text-align: center;
            z-index: 1000;
            opacity: 0; 
            visibility: hidden;
            transition: opacity 1s; 
        }

        #animation-stage.active {
            opacity: 1;
            visibility: visible;
        }

        #sarcastic-message {
            font-size: 0.5em;
            margin-bottom: 50px;
        }

        /* Addition Animation Container */
        #animation-content {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 200px;
            position: relative; 
        }
        
        .animated-number {
            font-family: 'Courier New', monospace; 
            font-size: 4em; 
            font-weight: bold;
            color: #99ff99;
            margin: 0 40px;
        }
        
        #operator-symbol {
            font-size: 4em;
            color: #ff99ff;
        }

        /* The Floating +1 Animation Bubble */
        #plus-one-bubble {
            position: absolute;
            font-size: 1.5em;
            color: yellow;
            background-color: #ff6666;
            border-radius: 50%;
            padding: 10px;
            opacity: 0;
            transition: transform 0.5s, opacity 0.5s; 
        }

        /* Final Result Text */
        #result-text {
            color: #99ff99; 
            font-size: 1em;
            margin-top: 20px;
        }

        /* Display and Buttons */
        #display-area { 
            background-color: #333; 
            color: limegreen; 
            padding: 10px; 
            border-radius: 5px; 
            margin-bottom: 20px; 
            border: 3px solid black; 
        }
        
        #formula { 
            min-height: 1.5em; 
            font-size: 1em; 
            opacity: 0.7;
            text-align: left; 
            white-space: nowrap; 
            overflow: hidden; 
            text-overflow: ellipsis;
        }
        
        #result { 
            font-size: 2.5em; 
            font-weight: bold; 
            text-align: right; 
        }
        
        #buttons-container { position: absolute; top: 100px; left: 20px; right: 20px; bottom: 20px; }
        .btn { 
            width: 80px; 
            height: 80px; 
            font-size: 1.5em;
            font-weight: bold;
            border: 3px solid #333;
            border-radius: 10px;
            cursor: pointer;
            margin: 5px; 
            position: absolute; 
            transition: background-color 0.1s; 
            box-shadow: 3px 3px 0 #333; 
            position: absolute;
            overflow: hidden; 
        }

        .btn:active { box-shadow: 0 0 0 #333; transform: translate(3px, 3px); }
        .operator { background-color: #ff99ff; }
        .control { background-color: #ff9999; }
        
        /* ENTER BUTTON STYLING */
        #enter-btn {
            width: 80px; 
            height: 80px; 
            font-size: 1.5em;
            font-weight: bold;
            border: 3px solid #0000ff;
            border-radius: 10px;
            background-color: #ccffff;
            text-align: center;
            padding: 0;
            box-sizing: border-box;
            position: absolute;
            box-shadow: 3px 3px 0 #000066;
            cursor: pointer;
        }
        #enter-btn:active {
            box-shadow: 0 0 0 #000066; 
            transform: translate(3px, 3px);
        }

        /* CHAINSaw STYLING FOR UNAVAILABLE OPERATORS */
        .unavailable-operator {
            cursor: not-allowed;
            background-color: #ff8080 !important; 
            color: #550000; 
            position: relative;
        }

        .unavailable-operator::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                linear-gradient(to top right, 
                    transparent 48%, 
                    rgba(255, 0, 0, 0.6) 48%, 
                    rgba(255, 0, 0, 0.6) 52%, 
                    transparent 52%),
                linear-gradient(to bottom right, 
                    transparent 48%, 
                    rgba(255, 0, 0, 0.6) 48%, 
                    rgba(255, 0, 0, 0.6) 52%, 
                    transparent 52%);
            z-index: 10;
        }
    </style>
</head>
<body>

    <div id="calculator">
        <div id="display-area">
            <div id="formula"></div>
            <div id="result">0</div>
        </div>
        <div id="buttons-container">
            
            <button class="btn" data-value="7">7</button>
            <button class="btn" data-value="8">8</button>
            <button class="btn" data-value="9">9</button>
            <button class="btn operator unavailable-operator" data-value="/">/</button> 
            
            <button class="btn" data-value="4">4</button>
            <button class="btn" data-value="5">5</button>
            <button class="btn" data-value="6">6</button>
            <button class="btn operator unavailable-operator" data-value="*">*</button>
            
            <button class="btn" data-value="1">1</button>
            <button class="btn" data-value="2">2</button>
            <button class="btn" data-value="3">3</button>
            <button class="btn operator unavailable-operator" data-value="-">-</button>
            
            <button class="btn" data-value="0">0</button>
            <button class="btn" data-value=".">.</button>
            
            <button id="enter-btn">ENTER</button>
            
            <button class="btn operator" data-value="+">+</button> 

            <button class="btn control" data-value="clear">AC</button>
        </div>
    </div>

    <div id="animation-stage">
        <p id="sarcastic-message">INITIATING CHAOS SEQUENCE...</p>
        <div id="animation-content"></div>
        <p id="result-text"></p>
        <button id="reset-btn" style="padding: 10px 20px; font-size: 1em; margin-top: 30px; cursor: pointer; border-radius: 5px;">Try Again?</button>
    </div>

    <script>
        const calculator = document.getElementById('calculator');
        const buttons = document.querySelectorAll('.btn');
        const enterBtn = document.getElementById('enter-btn');
        const container = document.getElementById('buttons-container');
        const formulaDisplay = document.getElementById('formula');
        const resultDisplay = document.getElementById('result');
        const animationStage = document.getElementById('animation-stage');
        const sarcasticMessage = document.getElementById('sarcastic-message');
        const resultText = document.getElementById('result-text');
        const resetBtn = document.getElementById('reset-btn');
        const animationContent = document.getElementById('animation-content');

        const PADDING = 10; 
        let CONTAINER_WIDTH, CONTAINER_HEIGHT;
        let currentExpression = '';

        // --- Positioning/Scattering Logic ---
        
        function updateContainerDimensions() { CONTAINER_WIDTH = container.clientWidth; CONTAINER_HEIGHT = container.clientHeight; }
        
        function isOverlapping(newRect, currentElements) {
            for (const otherElement of currentElements) {
                const isEnterButton = otherElement.id === 'enter-btn';
                if (isEnterButton && otherElement.style.position !== 'absolute') continue;

                const otherX = parseFloat(otherElement.style.left) || 0;
                const otherY = parseFloat(otherElement.style.top) || 0;
                const otherW = otherElement.offsetWidth;
                const otherH = otherElement.offsetHeight;

                if (newRect.x < otherX + otherW + PADDING &&
                    newRect.x + newRect.w + PADDING > otherX &&
                    newRect.y < otherY + otherH + PADDING &&
                    newRect.y + newRect.h + PADDING > otherY) {
                    return true;
                }
            }
            return false;
        }

        function scatterElement(element) {
            updateContainerDimensions();

            const elementWidth = element.offsetWidth;
            const elementHeight = element.offsetHeight;
            const maxX = CONTAINER_WIDTH - elementWidth - PADDING;
            const maxY = CONTAINER_HEIGHT - elementHeight - PADDING;
            
            const maxAttempts = 50; 
            let attempts = 0;
            let randomX, randomY;
            let overlap = true;
            
            const allElements = Array.from(buttons).concat([enterBtn]);

            while (overlap && attempts < maxAttempts) {
                attempts++;
                randomX = Math.floor(Math.random() * maxX);
                randomY = Math.floor(Math.random() * maxY);

                const proposedRect = { element: element, x: randomX, y: randomY, w: elementWidth, h: elementHeight };
                overlap = isOverlapping(proposedRect, allElements);
            }

            if (!overlap) {
                element.style.left = `${randomX}px`;
                element.style.top = `${randomY}px`;
            } else {
                element.style.left = `${Math.floor(Math.random() * maxX)}px`;
                element.style.top = `${Math.floor(Math.random() * maxY)}px`;
            }
        }

        function initializeScattering() {
            scatterElement(enterBtn);
            buttons.forEach(button => { scatterElement(button); });
        }

        window.addEventListener('load', initializeScattering);
        
        // --- END Positioning/Scattering Logic ---


        // --- Operation-Specific Animation Logic ---
        
        function parseSimpleOperation(expression) {
            const match = expression.match(/^(\d+(\.\d+)?)([\+\-\*\/])(\d+(\.\d+)?)$/);
            if (match) {
                return {
                    num1: parseFloat(match[1]),
                    operator: match[3],
                    num2: parseFloat(match[4])
                };
            }
            return null;
        }

        function animateAddition(num1, num2) {
            const start1 = Math.round(num1);
            let current1 = start1;
            let current2 = Math.round(num2);
            
            animationContent.innerHTML = `
                <div id="num1" class="animated-number">${current1}</div>
                <div id="operator-symbol">+</div>
                <div id="num2" class="animated-number">${current2}</div>
                <div id="plus-one-bubble"></div>
            `;
            
            const num1El = document.getElementById('num1');
            const num2El = document.getElementById('num2');
            const bubbleEl = document.getElementById('plus-one-bubble');

            sarcasticMessage.textContent = "TRANSFERRING..."; 
            
            // Calculate distances based on current layout
            const num2Rect = num2El.getBoundingClientRect();
            const num1Rect = num1El.getBoundingClientRect();
            const contentRect = animationContent.getBoundingClientRect();

            // Initial position of the bubble near num2 (the source - RIGHT SIDE)
            const startX = num2Rect.left - contentRect.left + (num2Rect.width / 2) - 20; 
            const startY = num2Rect.top - contentRect.top + (num2Rect.height / 2) - 20;

            // End position near num1 (the destination - LEFT SIDE)
            const endX = num1Rect.left - contentRect.left + (num1Rect.width / 2) - 20; 
            const endY = num1Rect.top - contentRect.top + (num1Rect.height / 2) - 20;

            // Calculate the necessary translation from Num2 (start) to Num1 (end)
            const translateX = endX - startX;
            const translateY = endY - startY; // Should be close to 0

            // Set the absolute position (start point, near Num2)
            bubbleEl.style.left = `${startX}px`;
            bubbleEl.style.top = `${startY}px`;
            bubbleEl.style.transform = `translate(0, 0)`; 

            return new Promise(resolve => {
                const totalSteps = current2;
                const MAX_STEPS = 50;
                const stepIncrement = Math.max(1, Math.ceil(totalSteps / MAX_STEPS));
                const animationDuration = 1250; 
                const moveTime = 500; 

                function runStep() {
                    if (current2 <= 0) {
                        num2El.textContent = '0';
                        sarcasticMessage.textContent = "COMPLETE!";
                        resolve(current1); 
                        return;
                    }
                    
                    // 1. Reset/Hide the bubble back to its absolute start position (near Num2)
                    bubbleEl.style.opacity = 0;
                    bubbleEl.style.transform = `translate(0, 0)`; // Reset translation
                    
                    // Force reflow/re-render to ensure the reset happens before the new transition
                    void bubbleEl.offsetWidth; 

                    // 2. Set the content and start the new movement
                    setTimeout(() => {
                        bubbleEl.textContent = `+${stepIncrement}`;
                        
                        // 3. Start the visible movement (opacity and translation)
                        bubbleEl.style.opacity = 1;
                        // Move from Num2 (start) to Num1 (end)
                        bubbleEl.style.transform = `translate(${translateX}px, ${translateY}px)`; 
                        
                        // 4. Update numbers after the bubble lands (after moveTime)
                        setTimeout(() => {
                            current1 += stepIncrement;
                            current2 -= stepIncrement;
                            
                            if (current2 < 0) {
                                current1 += current2; 
                                current2 = 0;
                            }

                            num1El.textContent = current1;
                            num2El.textContent = current2;
                            
                            // 5. Repeat the loop after the remaining delay (animationDuration - moveTime)
                            // This wait time is what gives the "slower x0.2" effect.
                            setTimeout(runStep, animationDuration - moveTime); 
                        }, moveTime); 
                    }, 50); // Small delay to separate the reset command from the transition start command
                }
                
                // Initiate the first step of the loop
                runStep();
            });
        }


        // --- Main Calculation and Animation Flow ---

        function calculateAndAnimate() {
            calculator.style.opacity = '0'; 

            // Wait 1 second before fading in the animation stage
            setTimeout(async () => {
                calculator.style.display = 'none';
                animationStage.classList.add('active'); 

                let finalResult;
                let message;
                let finalAnswerText;

                const simpleOp = parseSimpleOperation(currentExpression);
                
                animationContent.innerHTML = '';
                resultText.textContent = '';


                if (simpleOp && simpleOp.operator === '+' && !currentExpression.includes('.')) {
                    // --- Custom Addition Animation ---
                    try {
                        finalResult = await animateAddition(simpleOp.num1, simpleOp.num2);
                        message = "SUCCESS!"; 
                        finalAnswerText = `Result: ${finalResult}`;

                    } catch(e) {
                         message = "FAILURE!";
                         finalAnswerText = "CALCULATION FAILED";
                         finalResult = NaN;
                    }
                    
                } else {
                    // --- Standard/Sarcastic Logic for all other operations or invalid input ---
                    try {
                        finalResult = Function(`'use strict'; return (${currentExpression})`)();
                        
                        if (currentExpression.includes('/0')) {
                            message = "BROKEN!"; 
                            finalAnswerText = "ERROR 404: MATH NOT FOUND";
                        } else if (Math.random() < 0.2) { 
                            const offset = (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 5 + 1);
                            finalResult = (finalResult + offset); 
                            message = `OFFSET!`; 
                        } else {
                            message = "DONE!"; 
                        }
                        
                        finalAnswerText = `Result: ${finalResult.toString().includes('NaN') ? 'INVALID' : finalResult.toString()}`;
                        if (message === 'OFFSET!') {
                            finalAnswerText = `${finalResult.toFixed(2)} (APPROXIMATE)`;
                        }

                        animationContent.innerHTML = `<div class="animated-number">${finalAnswerText.replace('Result: ', '').replace(' (APPROXIMATE)', '')}</div>`;
                        sarcasticMessage.textContent = message;

                    } catch (e) {
                        message = "ERROR!"; 
                        finalAnswerText = "CALCULATION FAILED (SKILL ISSUE)";
                        sarcasticMessage.textContent = message;
                        animationContent.innerHTML = `<div class="animated-number" style="color:red">DENIED</div>`;
                    }
                }
                
                resultText.textContent = finalAnswerText;

            }, 1000); // 1000ms delay before animation starts
        }

        function resetCalculator() {
            animationStage.classList.remove('active');
            currentExpression = '';
            formulaDisplay.textContent = '';
            resultDisplay.textContent = '0';

            calculator.style.display = 'block';
            calculator.style.opacity = '1';
            
            initializeScattering(); 
        }

        // --- Event Handlers ---
        buttons.forEach(button => {
            button.addEventListener('click', (event) => {
                const value = event.target.dataset.value;
                const isUnavailable = button.classList.contains('unavailable-operator');

                if (isUnavailable) {
                    scatterElement(event.target);
                    return; 
                }

                scatterElement(event.target);

                if (value === 'clear') {
                    currentExpression = '';
                    resultDisplay.textContent = '0';
                    formulaDisplay.textContent = '';
                    return;
                }

                const isOperator = button.classList.contains('operator');
                const lastCharIsOperator = ['+', '-', '*', '/'].includes(currentExpression.slice(-1));

                if (isOperator && lastCharIsOperator) {
                    currentExpression = currentExpression.slice(0, -1) + value;
                } else if (isOperator || !isOperator) {
                    currentExpression += value;
                }
                
                formulaDisplay.textContent = currentExpression;
                resultDisplay.textContent = currentExpression.split(/[\+\-\*\/]/).pop() || '0';
            });
        });
        
        // Handle ENTER button click
        enterBtn.addEventListener('click', (event) => {
            scatterElement(enterBtn);
            calculateAndAnimate();
        });

        resetBtn.addEventListener('click', resetCalculator);

    </script> 
</body>
</html>