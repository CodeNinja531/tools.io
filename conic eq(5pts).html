<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conic Solver Minimal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Dark background */
            color: #c9d1d9;
        }
        /* Custom styling for the minimal interface */
        .input-box {
            background-color: #161b22;
            border: 1px solid #30363d;
            color: #c9d1d9;
            transition: border-color 0.2s;
        }
        .input-box:focus {
            border-color: #58a6ff;
            outline: none;
        }
        /* Style for the select controls */
        .select-control {
            background-color: #161b22;
            border: 1px solid #30363d;
            color: #c9d1d9;
            cursor: pointer;
            appearance: none; /* Hide default arrow */
            padding-right: 1.5rem; /* Space for custom arrow */
        }
        .copy-button {
            background-color: #30363d;
            color: #c9d1d9;
            border: 1px solid #30363d;
            transition: background-color 0.2s, border-color 0.2s;
        }
        .copy-button:hover {
            background-color: #58a6ff;
            border-color: #58a6ff;
            color: #0d1117;
        }
    </style>
</head>
<body class="p-4 sm:p-8 min-h-screen flex items-start justify-center">

<div class="w-full max-w-4xl pt-10">
    
    <!-- CONTROLS -->
    <div class="flex flex-col sm:flex-row justify-between items-center mb-6 space-y-3 sm:space-y-0">
        <div class="flex items-center space-x-4">
            <label for="point-count-select" class="text-sm font-medium text-gray-400">Number of Points (N):</label>
            <select id="point-count-select" class="p-1 rounded-md text-sm select-control" onchange="window.updateInputFields()">
                <option value="5" selected>5</option>
                <option value="6">6</option>
                <option value="7">7</option>
                <option value="8">8</option>
                <option value="9">9</option>
                <option value="10">10</option>
            </select>
        </div>

        <div class="flex items-center space-x-4">
            <label for="precision-select" class="text-sm font-medium text-gray-400">Precision (Decimal Places):</label>
            <select id="precision-select" class="p-1 rounded-md text-sm select-control" onchange="window.calculateConic()">
                <option value="5">5</option>
                <option value="6" selected>6</option>
                <option value="7">7</option>
                <option value="8">8</option>
                <option value="9">9</option>
                <option value="10">10</option>
            </select>
        </div>
    </div>
    
    <div id="input-container" class="grid grid-cols-2 sm:grid-cols-5 gap-4 mb-8">
        <!-- Input fields will be generated here by JavaScript -->
    </div>

    <!-- MAIN OUTPUT DISPLAY CONTAINER -->
    <div id="output-container" class="p-4 rounded-lg bg-[#161b22] shadow-xl border border-[#30363d]">
        <div class="flex justify-between items-start mb-2">
            <h3 class="text-lg font-semibold text-[#c9d1d9]">Equation Output (LaTeX Format)</h3>
            <button id="copy-button" onclick="window.copyToClipboard('equation-output')" class="copy-button px-3 py-1 text-xs rounded-md shadow-sm active:shadow-none focus:outline-none focus:ring-2 focus:ring-[#58a6ff]">
                Copy Equation
            </button>
        </div>

        <!-- LaTeX Equation Output -->
        <div id="equation-output" class="text-xl font-mono text-yellow-300 min-h-[1.5rem] font-bold break-words mb-4">
            Enter coordinates to calculate the conic equation.
        </div>
        
        <!-- User-Friendly Equation Output -->
        <div class="mt-4 border-t border-[#30363d] pt-4">
            <h3 class="text-lg font-semibold text-[#c9d1d9]">actual eq :)</h3>
            <div id="user-friendly-output" class="text-base font-mono text-green-400 min-h-[1.5rem] mt-2 break-words">
                N/A
            </div>
        </div>

        <!-- Conic Type Output (Unchanged) -->
        <div id="conic-type-output" class="mt-4 text-md text-[#58a6ff] border-t border-[#30363d] pt-4">
            Type: N/A
        </div>
        
        <!-- Range Output (Displaying the raw constraints string for reference) -->
        <div id="range-output" class="text-sm text-gray-400 font-mono mt-2">
            Bounding Box: N/A
        </div>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const inputContainer = document.getElementById('input-container');
        const equationOutput = document.getElementById('equation-output');
        const userFriendlyOutput = document.getElementById('user-friendly-output');
        const conicTypeOutput = document.getElementById('conic-type-output');
        const precisionSelect = document.getElementById('precision-select');
        const pointCountSelect = document.getElementById('point-count-select');
        const rangeOutput = document.getElementById('range-output'); 
        
        // --- Utility Constants ---
        const tolerance = 1e-9;
        const ONE_TOLERANCE = 1e-6; 
        const equalityTolerance = 1e-6; 

        // --- Matrix Helper Functions for Least Squares (Unchanged) ---

        const transpose = (M) => {
            const rows = M.length;
            const cols = M[0].length;
            const T = [];
            for (let j = 0; j < cols; j++) {
                T[j] = [];
                for (let i = 0; i < rows; i++) {
                    T[j][i] = M[i][j];
                }
            }
            return T;
        };

        const multiply = (A, B) => {
            const rowsA = A.length;
            const colsA = A[0].length;
            const rowsB = B.length;
            const colsB = B[0].length;

            if (colsA !== rowsB) {
                console.error("Matrix multiplication failed: inner dimensions must match.");
                return null;
            }

            const C = [];
            for (let i = 0; i < rowsA; i++) {
                C[i] = [];
                for (let j = 0; j < colsB; j++) {
                    let sum = 0;
                    for (let k = 0; k < colsA; k++) {
                        sum += A[i][k] * B[k][j];
                    }
                    C[i][j] = sum;
                }
            }
            return C;
        };
        
        const matrixVectorMultiply = (A, V) => {
            const rows = A.length;
            const cols = A[0].length;

            if (cols !== V.length) {
                console.error("Matrix-Vector multiplication failed: dimensions must match.");
                return null;
            }

            const R = new Array(rows);
            for (let i = 0; i < rows; i++) {
                let sum = 0;
                for (let j = 0; j < cols; j++) {
                    sum += A[i][j] * V[j];
                }
                R[i] = sum;
            }
            return R;
        };
        
        const solveMatrix = (A, b) => {
            const n = A.length;
            const M = []; 
            for (let i = 0; i < n; i++) {
                M.push([...A[i], b[i]]);
            }
            const tolerance = 1e-9;
            for (let k = 0; k < n; k++) {
                let i_max = k;
                for (let i = k + 1; i < n; i++) {
                    if (Math.abs(M[i][k]) > Math.abs(M[i_max][k])) {
                        i_max = i;
                    }
                }
                [M[k], M[i_max]] = [M[i_max], M[k]];

                if (Math.abs(M[k][k]) < tolerance) {
                    return null; 
                }

                for (let i = k + 1; i < n; i++) {
                    const factor = M[i][k] / M[k][k];
                    for (let j = k; j < n + 1; j++) {
                        M[i][j] -= factor * M[k][j];
                    }
                }
            }

            const x = new Array(n).fill(0);
            for (let i = n - 1; i >= 0; i--) {
                let sum = 0;
                for (let j = i + 1; j < n; j++) {
                    sum += M[i][j] * x[j];
                }
                x[i] = (M[i][n] - sum) / M[i][i];
            }

            return x;
        };

        // --- Clipboard Function ---
        window.copyToClipboard = (elementId) => {
            const element = document.getElementById(elementId);
            const textToCopy = element.textContent;

            // Use the fallback method for copying to clipboard inside an iframe
            const textarea = document.createElement('textarea');
            textarea.value = textToCopy;
            textarea.style.position = 'fixed'; // Prevents scrolling to bottom
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            
            try {
                const successful = document.execCommand('copy');
                const msg = successful ? 'Copied!' : 'Copy failed.';
                
                const originalText = document.getElementById('copy-button').textContent;
                document.getElementById('copy-button').textContent = msg;
                setTimeout(() => {
                    document.getElementById('copy-button').textContent = originalText;
                }, 1500);

            } catch (err) {
                console.error('Could not copy text: ', err);
            }
            document.body.removeChild(textarea);
        };
        
        // --- UI Generation & Update (Unchanged) ---
        window.updateInputFields = () => {
            const N = parseInt(pointCountSelect.value, 10);
            inputContainer.innerHTML = '';

            for (let i = 0; i < N; i++) {
                // X Input
                const xInput = document.createElement('input');
                xInput.type = 'number';
                xInput.dataset.point = i;
                xInput.dataset.coord = 'x';
                xInput.value = ''; 
                xInput.step = '0.01';
                xInput.placeholder = `P${i+1} X`;
                xInput.className = 'w-full p-2 rounded-md input-box text-sm';
                xInput.oninput = window.calculateConic; 

                // Y Input
                const yInput = document.createElement('input');
                yInput.type = 'number';
                yInput.dataset.point = i;
                yInput.dataset.coord = 'y';
                yInput.value = ''; 
                yInput.step = '0.01';
                yInput.placeholder = `P${i+1} Y`;
                yInput.className = 'w-full p-2 rounded-md input-box text-sm';
                yInput.oninput = window.calculateConic; 

                const wrapper = document.createElement('div');
                wrapper.className = 'flex flex-col space-y-1';
                wrapper.appendChild(xInput);
                wrapper.appendChild(yInput);
                inputContainer.appendChild(wrapper);
            }
            window.calculateConic();
        };

        /**
         * Formats a single term for the equation output.
         * @param {number} c Coefficient.
         * @param {string} termName Variable part (e.g., "x^{2}" or "x^2").
         * @param {boolean} isFirst If this is the first non-zero term.
         * @param {boolean} isLaTeX If true, uses LaTeX formatting (superscripts, space around sign).
         * @param {number} precision Decimal places to use.
         * @returns {string} Formatted term string.
         */
        const formatTerm = (c, termName, isFirst, isLaTeX, precision) => {
            if (Math.abs(c) < tolerance) return "";

            const sign = c >= 0 ? (isFirst ? "" : " + ") : (isFirst ? "-" : " - ");
            const absC = Math.abs(c);
            
            let val;
            
            // Omit the number if close to 1 or -1
            if (Math.abs(absC - 1.0) < ONE_TOLERANCE) { 
                val = isLaTeX ? (isFirst && c < 0 ? "" : "") : "";
            } else {
                val = absC.toFixed(precision); 
            }

            const prefix = isFirst ? sign : (c >= 0 ? " + " : " - ");
            let term = val + termName;
            
            if (isLaTeX) {
                // LaTeX format needs specific sign handling for the first term
                if (isFirst) {
                    if (c < 0 && val === "") return "-" + termName; // -x^2 case
                    if (c < 0) return "-" + val + termName;
                    return val + termName; // Positive case
                } else {
                    // Subsequent terms need the sign string explicitly
                    return (c >= 0 ? " + " : " - ") + val + termName;
                }
            } else {
                // User-friendly format is simpler
                let termString = val + termName;
                if (isFirst) {
                    return c < 0 ? "-" + termString : termString;
                } else {
                    return c < 0 ? " - " + termString : " + " + termString;
                }
            }
        };


        // --- Conic Calculation Function ---
        window.calculateConic = () => {
            const N = parseInt(pointCountSelect.value, 10);
            let points = [];
            const PRECISION = parseInt(precisionSelect.value, 10);
            const PLAIN_PRECISION = 4; // Fixed precision for the user-friendly output

            let hasIncompleteInput = false;
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;

            // 1. Collect points and update bounding box
            for (let i = 0; i < N; i++) {
                const xInput = document.querySelector(`input[data-point="${i}"][data-coord="x"]`);
                const yInput = document.querySelector(`input[data-point="${i}"][data-coord="y"]`);
                
                if (!xInput || !yInput) { hasIncompleteInput = true; break; }

                const x = parseFloat(xInput.value);
                const y = parseFloat(yInput.value);

                if (isNaN(x) || isNaN(y)) { hasIncompleteInput = true; points = []; break; }

                points.push({x, y});
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }

            if (hasIncompleteInput) {
                equationOutput.textContent = "Please enter valid X and Y coordinates for all " + N + " points.";
                userFriendlyOutput.textContent = "N/A";
                conicTypeOutput.textContent = "Type: Incomplete Input";
                rangeOutput.textContent = "Bounding Box: N/A";
                return;
            }

            // 2. Setup Least Squares System
            const M_prime = []; 
            const b = [];       
            const F_val = 1.0; 

            points.forEach(({x, y}) => {
                const row = [ x * x, x * y, y * y, x, y ];
                M_prime.push(row);
                b.push(F_val); 
            });
            
            const M_prime_T = transpose(M_prime); 
            const A_normal = multiply(M_prime_T, M_prime); 
            const b_normal = matrixVectorMultiply(M_prime_T, b); 

            const solution = solveMatrix(A_normal, b_normal);

            if (!solution) {
                equationOutput.textContent = "The matrix is singular. The points are degenerate, or the desired conic passes through the origin (which this method cannot solve).";
                userFriendlyOutput.textContent = "N/A";
                conicTypeOutput.textContent = "Type: Degenerate/Non-Unique";
                rangeOutput.textContent = "Bounding Box: N/A";
                return;
            }

            const [A, B, C, D, E] = solution;

            // 3. Classify the Conic
            const discriminant = B * B - 4 * A * C;
            
            let conicType = "General Conic";

            if (Math.abs(A) < tolerance && Math.abs(C) < tolerance && Math.abs(B) < tolerance) {
                conicType = "Degenerate Conic (Line or Line Pair)"; 
            } else if (Math.abs(discriminant) < tolerance) {
                conicType = "Parabola";
            } else if (discriminant < 0) {
                if (Math.abs(A - C) < tolerance && Math.abs(B) < tolerance) {
                    conicType = "Circle (Special Ellipse)";
                } else {
                    conicType = "Ellipse";
                }
            } else if (discriminant > 0) {
                conicType = "Hyperbola";
            }

            conicTypeOutput.textContent = `Type: ${conicType}`;

            // 4. Format the Equations
            const coefficients = [A, B, C, D, E];
            const latexVariables = ["x^{2}", "xy", "y^{2}", "x", "y"]; 
            const plainVariables = ["x^2", "xy", "y^2", "x", "y"]; 
            
            let latexParts = [];
            let plainParts = [];
            let isFirstTerm = true;
            
            for(let i = 0; i < coefficients.length; i++) {
                const c = coefficients[i];
                if (Math.abs(c) < tolerance) continue; // Skip zero terms
                
                // --- LaTeX Format ---
                const latexTerm = formatTerm(c, latexVariables[i], isFirstTerm, true, PRECISION);
                latexParts.push(latexTerm);

                // --- User-Friendly Format (fixed 4 decimal places) ---
                const plainTerm = formatTerm(c, plainVariables[i], isFirstTerm, false, PLAIN_PRECISION);
                plainParts.push(plainTerm);

                isFirstTerm = false; 
            }
            
            let equationString = latexParts.join('').trim();
            let userFriendlyString = plainParts.join('').trim();

            if (equationString.startsWith('+')) {
                equationString = equationString.substring(1).trim();
            }
            if (userFriendlyString.startsWith('+')) {
                userFriendlyString = userFriendlyString.substring(1).trim();
            }

            // 5. Generate Bounding Box (Only for Open Conics)
            let rangeDisplay = "";
            let shouldDisplayRange = !(conicType.includes("Ellipse") || conicType.includes("Circle"));
            let userFriendlyRangeDisplay = "";

            if (shouldDisplayRange) {
                const format = (val) => val.toFixed(PRECISION);
                const formatPlain = (val) => val.toFixed(PLAIN_PRECISION);
                let rangeParts = [];
                let plainRangeParts = [];
                
                // --- X-Axis Constraint Formatting ---
                const rangeX = maxX - minX;
                if (rangeX < equalityTolerance) {
                    // Equality: {x = V}
                    rangeParts.push(`\\left\\{x = ${format(minX)}\\right\\}`);
                    plainRangeParts.push(`{x = ${formatPlain(minX)}}`);
                } else {
                    // Range: {maxX >= x >= minX}
                    rangeParts.push(`\\left\\{${format(maxX)} \\ge x \\ge ${format(minX)}\\right\\}`);
                    plainRangeParts.push(`{${formatPlain(minX)} <= x <= ${formatPlain(maxX)}}`);
                }

                // --- Y-Axis Constraint Formatting ---
                const rangeY = maxY - minY;
                if (rangeY < equalityTolerance) {
                    // Equality: {y = V}
                    rangeParts.push(`\\left\\{y = ${format(minY)}\\right\\}`);
                    plainRangeParts.push(`{y = ${formatPlain(minY)}}`);
                } else {
                    // Range: {maxY >= y >= minY}
                    rangeParts.push(`\\left\\{${format(maxY)} \\ge y \\ge ${format(minY)}\\right\\}`);
                    plainRangeParts.push(`{${formatPlain(minY)} <= y <= ${formatPlain(maxY)}}`);
                }
                
                rangeDisplay = rangeParts.join(''); 
                userFriendlyRangeDisplay = plainRangeParts.join(' ');
                rangeOutput.textContent = `Bounding Box: ${rangeDisplay} (Displayed only for open conics)`;
            } else {
                 rangeOutput.textContent = `Bounding Box: Omitted (Closed shape: ${conicType} is inherently bounded)`;
            }

            // 6. Final Output Assembly
            if (equationString === "") {
                equationOutput.textContent = `0 = 1 (Degenerate Conic)`;
                userFriendlyOutput.textContent = `0 = 1 (Degenerate Conic)`;
                rangeOutput.textContent = "Bounding Box: N/A";
            } else {
                const finalEquation = `${equationString} = 1 ${rangeDisplay}`; 
                equationOutput.textContent = finalEquation; 

                const finalUserFriendly = `${userFriendlyString} = 1 ${userFriendlyRangeDisplay}`;
                userFriendlyOutput.textContent = finalUserFriendly;
            }
        };

        // Initialize with default 5 inputs
        window.updateInputFields();
    });
</script>

</body>
</html>
